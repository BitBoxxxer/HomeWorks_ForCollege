---		Указатель		---

Для указатель нужно указывать не '... = 0;', a '... = NULL' || '... = nullptr'
Пример:
int* p = nullptr; int* p = NULL;

Тогда: (=> - вывод в консоль.)

cout << p; => ewqeiqwoiewp0101010 
(выводит адрес)
cout << *p; => 0 
(вывод числа из адреса.)

*p не может принимать значения, принимает оно только адреса. Пример:

int a = 5;
int *p = &a;

Так же 
p++ => смещение 'p' на 4 байта вправо

---

int* const p = &a; -> Указатель на константу (p привязана к a, не может свести свой фокус на
другие переменные.)

Но если:
const int* p = &a;
p = &b; -> Тогда p может смещать свой фокус


---		Ссылки		---

```
int& f2(int& a, int& b)
{
	int c = a * b;
	return c;
}

int main()
{
	int a = 2, b = 4;
	cout << f2(a, b);
}
```
 // f2(a, b)++ не сработает, т.к. возвращаемое значение - ссылка, что была удалена после использования функции.

Пример 2 (Нашли максимальный элемент в коллекции и присвоили ему значение '0')
```
int& f(int n, int a[])
{
	int max = 0;
	for (int i = 0; i < n; i++)
	{
		max = a[max] > a[i] ? max : i;
	}
	return a[max];
}

int main()
{
	int n = 0;
	cin >> n;
	int* a = new int[n];
	srand(time(0));
	for (int i = 0; i < n; i++)
	{
		a[i] = rand() % 100 - 50;
		cout << a[i] << " ";
	}

	f(n, a) = 0; // представление функции в виде переменной.
	cout << endl;
	for (int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}
}
```

[2-ая пара:]

new int - [динамический массив]

(Делаю лабу)

